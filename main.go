// Package main (fauxmailer) generates fake emails and sends them via SMTP
package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"log"
	"math/rand"
	"net/smtp"
	"os"
	"strings"
	"time"

	"github.com/manveru/faker"
)

var (
	// Flags
	delay     = flag.Duration("every", 0, "sends a message every <duration> if non-zero")
	host      = flag.String("host", "localhost:25", "host:port of SMTP server")
	signature = flag.String(
		"signature",
		"Generated by https://github.com/jhillyerd/fauxmailer",
		"signature")
	silent  = flag.Bool("silent", false, "disable to/from address log")
	tofile  = flag.String("tofile", "", "optional file containing newline separated To addresses")
	verbose = flag.Bool("verbose", false, "enable verbose output")

	random  = rand.New(rand.NewSource(time.Now().UnixNano()))
	toaddrs []string
)

// message represents an unencoded email message
type message struct {
	from, to, subject, body string
}

func main() {
	flag.Parse()
	fake, err := faker.New("en")
	if err != nil {
		log.Fatal(err)
	}
	// Load To address set if specified
	if *tofile != "" {
		err = loadToAddresses()
		if err != nil {
			log.Fatal(err)
		}
	}
	b := new(bytes.Buffer)
	for {
		m := generateMessage(fake)
		if !*silent {
			log.Println(m.from, "->", m.to)
		}
		if err = encodeMessage(b, m); err != nil {
			log.Fatal(err)
		}
		if err = sendMessage(*host, m, b); err != nil {
			log.Fatal(err)
		}
		// Loop if delay was specified
		if *delay > 0 {
			time.Sleep(*delay)
		} else {
			return
		}
	}
}

// generateMessage uses faker to create a random message struct
func generateMessage(fake *faker.Faker) message {
	// Use provided To address if available
	var to string
	if toaddrs != nil {
		to = toaddrs[random.Intn(len(toaddrs))]
	} else {
		to = fake.Email()
	}
	from := fake.Email()
	company := fake.CompanyName()
	cosig := fmt.Sprintf("%s <%s>, %s\r\n%s, \"%s\"",
		fake.Name(),
		from,
		fake.JobTitle(),
		company,
		fake.CompanyCatchPhrase())
	paragraphs := fake.Paragraphs(4, true)
	paragraphs = append(paragraphs, cosig)

	return message{
		from:    from,
		to:      to,
		subject: strings.Title(fake.CompanyBs()) + " with " + company,
		body:    strings.Join(paragraphs, "\r\n\r\n"),
	}
}

// encodeMessage writes an encoded message to buf b
func encodeMessage(b *bytes.Buffer, m message) error {
	b.Reset()
	b.WriteString("From: ")
	b.WriteString(m.from)
	b.WriteString("\r\nTo: ")
	b.WriteString(m.to)
	b.WriteString("\r\nDate: ")
	b.WriteString(time.Now().Format(time.RFC1123Z))
	b.WriteString("\r\nSubject: ")
	b.WriteString(m.subject)
	b.WriteString("\r\nUser-Agent: fauxmailer")
	b.WriteString("\r\nContent-type: text/plain; charset=utf-8")
	b.WriteString("\r\n\r\n")
	b.WriteString(m.body)
	if *signature != "" {
		b.WriteString("\r\n\r\n--\r\n")
		b.WriteString(*signature)
	}
	_, err := b.WriteString("\r\n")
	return err
}

// sendMessage connects to specified SMTP host, sends buf b to m.to
func sendMessage(host string, m message, b *bytes.Buffer) error {
	to := []string{m.to}
	if *verbose {
		log.Printf("Sending:\n%s", b.String())
	}
	return smtp.SendMail(host, nil, m.from, to, b.Bytes())
}

// loadToAddresses from specified file, one per line
func loadToAddresses() error {
	f, err := os.Open(*tofile)
	if err != nil {
		return err
	}
	toaddrs = make([]string, 0)
	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		addr := strings.TrimSpace(scanner.Text())
		if addr != "" {
			toaddrs = append(toaddrs, addr)
			if *verbose {
				log.Printf("Added To address: %s", addr)
			}
		}
	}
	return scanner.Err()
}
