// Package main generate fake emails sent via SMTP
package main

import (
	"bytes"
	"flag"
	"fmt"
	"log"
	"net/smtp"
	"strings"
	"time"

	"github.com/manveru/faker"
)

var (
	// Flags
	delay   = flag.Duration("every", 0, "sends a message every <duration> if non-zero")
	host    = flag.String("host", "localhost:25", "host:port of SMTP server")
	silent  = flag.Bool("silent", false, "disable to/from address log")
	verbose = flag.Bool("verbose", false, "enable verbose output")

	// Default signature appended to sent messages
	signature = "Generated by https://github.com/jhillyerd/fauxmailer"
)

// message represents an unencoded email message
type message struct {
	from, to, subject, body string
}

func main() {
	flag.Parse()
	fake, err := faker.New("en")
	if err != nil {
		log.Fatal(err)
	}
	b := new(bytes.Buffer)
	for {
		m := generateMessage(fake)
		if !*silent {
			log.Println(m.from, "->", m.to)
		}
		if err = encodeMessage(b, m); err != nil {
			log.Fatal(err)
		}
		if err = sendMessage(*host, m, b); err != nil {
			log.Fatal(err)
		}
		// Loop if delay was specified
		if *delay > 0 {
			time.Sleep(*delay)
		} else {
			return
		}
	}
}

// generateMessage uses faker to create a random message struct
func generateMessage(fake *faker.Faker) message {
	from := fake.Email()
	company := fake.CompanyName()
	cosig := fmt.Sprintf("%s <%s>, %s\r\n%s, \"%s\"",
		fake.Name(),
		from,
		fake.JobTitle(),
		company,
		fake.CompanyCatchPhrase())
	paragraphs := fake.Paragraphs(4, true)
	paragraphs = append(paragraphs, cosig)

	return message{
		from:    from,
		to:      fake.Email(),
		subject: strings.Title(fake.CompanyBs()) + " with " + company,
		body:    strings.Join(paragraphs, "\r\n\r\n"),
	}
}

// encodeMessage writes an encoded message to b
func encodeMessage(b *bytes.Buffer, m message) error {
	b.Reset()
	b.WriteString("From: ")
	b.WriteString(m.from)
	b.WriteString("\r\nTo: ")
	b.WriteString(m.to)
	b.WriteString("\r\nDate: ")
	b.WriteString(time.Now().Format(time.RFC1123Z))
	b.WriteString("\r\nSubject: ")
	b.WriteString(m.subject)
	b.WriteString("\r\n\r\n")
	b.WriteString(m.body)
	if signature != "" {
		b.WriteString("\r\n\r\n--\r\n")
		b.WriteString(signature)
	}
	_, err := b.WriteString("\r\n")
	return err
}

func sendMessage(host string, m message, b *bytes.Buffer) error {
	to := []string{m.to}
	if *verbose {
		log.Printf("Sending:\n%s", b.String())
	}
	return smtp.SendMail(host, nil, m.from, to, b.Bytes())
}
